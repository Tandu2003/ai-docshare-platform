---
type: 'mdc'
alwaysApply: true
---

# Development Philosophy & Implementation Guidelines

## Core Development Philosophy

### Principles

- Write **clean, maintainable, and scalable** code
- Follow **SOLID principles** rigorously
- Prefer **functional and declarative** programming patterns over imperative
- Emphasize **type safety and static analysis**
- Practice **component-driven development**

### Code Implementation Approach

1. **Start with step-by-step planning**
2. **Write pseudocode before implementation**
3. **Document component architecture and data flow**
4. **Consider edge cases and error scenarios**

## Code Style & Formatting

### Indentation & Spacing

- Use **tabs for indentation**
- **Omit semicolons** unless required
- **Limit line length to 80 characters**
- **Space after keywords**, before function parentheses, around operators, after commas

### String Usage

- Use **single quotes for strings** (except to avoid escaping)
- Example: `const message = 'Hello world'`

### Equality & Control Flow

- **Always use strict equality** (`===`)
- **Keep else statements on same line** as closing brace
- **Use braces for multi-line if statements**

### Code Cleanliness

- **Remove unused variables**
- **Add trailing commas** in multiline objects/arrays

### Example Formatting

```typescript
function handleSubmit(event: FormEvent) {
  event.preventDefault();

  if (isValid) {
    dispatch(
      submitForm({
        data: formData,
        options: {
          validate: true,
          notify: true,
        },
      }),
    );
  } else {
    setError('Please fix validation errors');
  }
}
```

## Naming Conventions

### Case Patterns

- **PascalCase**: Components, Types, Interfaces (`UserProfile`, `AuthState`)
- **camelCase**: variables, functions, hooks, props (`getUserById`, `useAuth`)
- **kebab-case**: directories and filenames (`auth-wizard/`, `user-profile.tsx`)
- **UPPERCASE**: environment variables, constants, configs (`API_URL`, `MAX_RETRIES`)

### Specific Naming Patterns

- **Event handlers**: `handleClick`, `handleSubmit`, `handleInputChange`
- **Booleans**: `isLoading`, `hasError`, `canSubmit`, `isValid`
- **Hooks**: `useAuth`, `useForm`, `useDocuments`
- **Avoid abbreviations** except: `err`, `req`, `res`, `props`, `ref`

## React Best Practices

### Component Definition

- Use **functional components with TypeScript interfaces**
- **Define with the `function` keyword** (not arrow functions)
- Extract reusable logic into **custom hooks**
- Apply proper **component composition**

### Performance Optimization

- Use **React.memo** for expensive components
- Use **useCallback** and **useMemo** for performance
- **Perform cleanup in useEffect**
- Use **React.lazy + Suspense** for code splitting
- Use **stable key props in lists** (never use index)

### Component Structure Example

```typescript
interface UserCardProps {
  user: User;
  onEdit: (userId: string) => void;
  canEdit: boolean;
}

export function UserCard({ user, onEdit, canEdit }: UserCardProps) {
  const { isLoading, hasError } = useUserStatus(user.id);

  if (hasError) return <ErrorMessage />;
  if (isLoading) return <Skeleton />;

  return (
    <Card className='p-4'>
      <UserAvatar user={user} />
      <UserInfo user={user} />
      {canEdit && <Button onClick={() => onEdit(user.id)}>Edit User</Button>}
    </Card>
  );
}
```

## State Management (Redux Toolkit)

### Architecture

- Use **createSlice + configureStore**
- **Organize slices per feature** (`features/auth-slice.ts`)
- **Normalize state**, avoid deep nesting
- **Use selectors** (memoized with createSelector)
- **Avoid large monolithic slices** → split by domain
- Use **useState/useReducer for local state**

### Redux Implementation Example

```typescript
// features/auth/auth-slice.ts
interface AuthState {
  user: User | null;
  isLoading: boolean;
  hasError: boolean;
  errorMessage: string | null;
}

const initialState: AuthState = {
  user: null,
  isLoading: false,
  hasError: false,
  errorMessage: null,
};

export const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    setUser: (state, action: PayloadAction<User>) => {
      state.user = action.payload;
      state.hasError = false;
      state.errorMessage = null;
    },
    setLoading: (state, action: PayloadAction<boolean>) => {
      state.isLoading = action.payload;
    },
    setError: (state, action: PayloadAction<string>) => {
      state.hasError = true;
      state.errorMessage = action.payload;
      state.user = null;
    },
  },
});

// Selectors with memoization
export const selectUser = (state: RootState) => state.auth.user;
export const selectIsAuthenticated = createSelector([selectUser], (user) => user !== null);
```

## TypeScript Guidelines

### Configuration

- **Enable strict mode**
- **Prefer interface over type** (except for unions)
- Use **generics where needed**
- Apply **type guards for null/undefined safety**

### Type Usage

- Use **utility types** (`Partial`, `Omit`, `Pick`)
- Leverage **mapped types** for reusable variations
- Implement **proper type guards**

### Type Safety Example

```typescript
interface ApiResponse<T> {
  data: T;
  status: 'success' | 'error';
  message?: string;
}

interface User {
  id: string;
  email: string;
  name: string;
}

// Type guard
function isUser(obj: unknown): obj is User {
  return typeof obj === 'object' && obj !== null && 'id' in obj && 'email' in obj && 'name' in obj;
}

// Utility types
type CreateUserRequest = Omit<User, 'id'>;
type UpdateUserRequest = Partial<User>;
```

## UI & Styling

### Component Libraries

- Use **Shadcn UI + Radix UI primitives**
- **Tailwind CSS for utility-first styling**
- **Mobile-first responsive design**
- Implement **dark mode** via Tailwind or CSS variables

### Accessibility

- **Semantic HTML**, logical heading hierarchy
- **Proper ARIA attributes**
- **Full keyboard navigation**
- **Manage focus order and visibility**
- **Accessible error feedback**

### Styling Example

```typescript
function UserProfile({ user }: { user: User }) {
  return (
    <div className='max-w-2xl mx-auto p-4 sm:p-6 lg:p-8'>
      <Card className='space-y-4'>
        <CardHeader>
          <CardTitle className='text-2xl font-bold'>{user.name}</CardTitle>
          <CardDescription>{user.email}</CardDescription>
        </CardHeader>

        <CardContent className='space-y-4'>
          <UserStats user={user} />
          <UserActions user={user} />
        </CardContent>
      </Card>
    </div>
  );
}
```

## Error Handling & Validation

### Form Handling

- **Forms → React Hook Form + Zod**
- **Display clear error messages**
- Use **Error Boundaries** for graceful fallback UIs
- **Log errors to external services** (e.g., Sentry)

### Validation Example

```typescript
import { z } from 'zod';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

const userSchema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.string().email('Invalid email address'),
  age: z.number().min(18, 'Must be at least 18 years old'),
});

type UserFormData = z.infer<typeof userSchema>;

function UserForm() {
  const {
    register,
    handleSubmit,
    formState: { errors, isValid },
  } = useForm<UserFormData>({
    resolver: zodResolver(userSchema),
  });

  const onSubmit = (data: UserFormData) => {
    // Handle form submission
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)} className='space-y-4'>
      <div>
        <Input {...register('name')} placeholder='Enter name' aria-invalid={!!errors.name} />
        {errors.name && <p className='text-red-500 text-sm'>{errors.name.message}</p>}
      </div>

      <Button type='submit' disabled={!isValid}>
        Submit
      </Button>
    </form>
  );
}
```

## Testing

### Testing Strategy

- **Unit testing**: Jest + React Testing Library
- Follow **Arrange → Act → Assert**
- **Mock APIs/external dependencies**
- **Integration tests**: cover real workflows
- Use **snapshot testing sparingly**

### Test Example

```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import { UserCard } from './UserCard';

describe('UserCard', () => {
  const mockUser = {
    id: '1',
    name: 'John Doe',
    email: 'john@example.com',
  };

  const mockOnEdit = jest.fn();

  it('renders user information correctly', () => {
    render(<UserCard user={mockUser} onEdit={mockOnEdit} canEdit={true} />);

    expect(screen.getByText('John Doe')).toBeInTheDocument();
    expect(screen.getByText('john@example.com')).toBeInTheDocument();
  });

  it('calls onEdit when edit button is clicked', () => {
    render(<UserCard user={mockUser} onEdit={mockOnEdit} canEdit={true} />);

    fireEvent.click(screen.getByText('Edit User'));
    expect(mockOnEdit).toHaveBeenCalledWith('1');
  });
});
```

## Security

### Input Sanitization

- **Sanitize user input** (DOMPurify)
- **Implement proper authentication and authorization**
- **Prevent XSS/Injection attacks**
- **Validate all inputs** before processing

### Security Example

```typescript
import DOMPurify from 'dompurify';

function sanitizeUserInput(input: string): string {
  return DOMPurify.sanitize(input, {
    ALLOWED_TAGS: ['b', 'i', 'em', 'strong'],
    ALLOWED_ATTR: [],
  });
}

function UserComment({ comment }: { comment: string }) {
  const sanitizedComment = sanitizeUserInput(comment);

  return (
    <div
      dangerouslySetInnerHTML={{
        __html: sanitizedComment,
      }}
    />
  );
}
```
